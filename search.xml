<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BZOJ1941 Hide and Seek(kd_Tree模板题)</title>
    <url>/bcRevincent.github.io/BZOJ1941/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cDovL3d3dy5seWRzeS5jb20vSnVkZ2VPbmxpbmUvcHJvYmxlbS5waHA/aWQ9MTk0MQ==">题目传送门：bzoj 1941</span></p>
<h1 id="1-题目"><a class="markdownIt-Anchor" href="#1-题目">#</a> 1. 题目</h1>
<p>题意：求每个点到其中任意一个点的最大值和最小值的差的最小值。</p>
<p>注意：最小值初始化不能设为 0，因为不能是同一个点。</p>
<hr>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2. 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 1941</span></span><br><span class="line"><span class="comment">    User: Revincent</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:1644 ms</span></span><br><span class="line"><span class="comment">    Memory:16452 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,root,d;</span><br><span class="line"><span class="keyword">int</span> Min,Max,X,Y;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,xy[<span class="number">2</span>],Max[<span class="number">2</span>],Min[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.xy[d] == b.xy[d])</span><br><span class="line">             <span class="keyword">return</span> a.xy[d^<span class="number">1</span>] &lt; b.xy[d^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a.xy[d] &lt; b.xy[d];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=getchar())==<span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> v = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = getchar()) != <span class="string">&#x27; &#x27;</span> &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        v = v * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> v * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[rt].Min[<span class="number">0</span>] = min(p[rt].Min[<span class="number">0</span>], p[ch].Min[<span class="number">0</span>]);</span><br><span class="line">    p[rt].Min[<span class="number">1</span>] = min(p[rt].Min[<span class="number">1</span>], p[ch].Min[<span class="number">1</span>]);</span><br><span class="line">    p[rt].Max[<span class="number">0</span>] = max(p[rt].Max[<span class="number">0</span>], p[ch].Max[<span class="number">0</span>]);</span><br><span class="line">    p[rt].Max[<span class="number">1</span>] = max(p[rt].Max[<span class="number">1</span>], p[ch].Max[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    d = o;</span><br><span class="line">    nth_element(p+l, p+mid, p+r+<span class="number">1</span>);</span><br><span class="line">    p[mid].Min[<span class="number">0</span>] = p[mid].Max[<span class="number">0</span>] = p[mid].xy[<span class="number">0</span>];</span><br><span class="line">    p[mid].Min[<span class="number">1</span>] = p[mid].Max[<span class="number">1</span>] = p[mid].xy[<span class="number">1</span>];</span><br><span class="line">    p[mid].l = p[mid].r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; mid)p[mid].l = build(l, mid<span class="number">-1</span>, o^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)p[mid].r = build(mid+<span class="number">1</span>, r, o^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p[mid].l)push_up(mid, p[mid].l);</span><br><span class="line">    <span class="keyword">if</span>(p[mid].r)push_up(mid, p[mid].r);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(node a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(X &gt; a.Max[<span class="number">0</span>])res += X - a.Max[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(X &lt; a.Min[<span class="number">0</span>])res += a.Min[<span class="number">0</span>] - X;</span><br><span class="line">    <span class="keyword">if</span>(Y &gt; a.Max[<span class="number">1</span>])res += Y - a.Max[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(Y &lt; a.Min[<span class="number">1</span>])res += a.Min[<span class="number">1</span>] - Y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">abs</span>(p[rt].xy[<span class="number">0</span>] - X) + <span class="built_in">abs</span>(p[rt].xy[<span class="number">1</span>] - Y);</span><br><span class="line">    <span class="keyword">if</span>(dis)Min = min(Min, dis);</span><br><span class="line">    <span class="keyword">int</span> lmin = inf,rmin = inf;</span><br><span class="line">    <span class="keyword">if</span>(p[rt].l)lmin = get_min(p[p[rt].l]);</span><br><span class="line">    <span class="keyword">if</span>(p[rt].r)rmin = get_min(p[p[rt].r]);</span><br><span class="line">    <span class="keyword">if</span>(lmin &lt; rmin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lmin &lt; Min)query_min(p[rt].l);</span><br><span class="line">        <span class="keyword">if</span>(rmin &lt; Min)query_min(p[rt].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rmin &lt; Min)query_min(p[rt].r);</span><br><span class="line">        <span class="keyword">if</span>(lmin &lt; Min)query_min(p[rt].l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">(node a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res += max(<span class="built_in">abs</span>(a.Min[<span class="number">0</span>]-X), <span class="built_in">abs</span>(a.Max[<span class="number">0</span>]-X));</span><br><span class="line">    res += max(<span class="built_in">abs</span>(a.Min[<span class="number">1</span>]-Y), <span class="built_in">abs</span>(a.Max[<span class="number">1</span>]-Y));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">abs</span>(p[rt].xy[<span class="number">0</span>] - X) + <span class="built_in">abs</span>(p[rt].xy[<span class="number">1</span>] - Y);</span><br><span class="line">    <span class="keyword">if</span>(dis)Max = max(Max, dis);</span><br><span class="line">    <span class="keyword">int</span> lmax = -inf,rmax = -inf;</span><br><span class="line">    <span class="keyword">if</span>(p[rt].l)lmax = get_max(p[p[rt].l]);</span><br><span class="line">    <span class="keyword">if</span>(p[rt].r)rmax = get_max(p[p[rt].r]);</span><br><span class="line">    <span class="keyword">if</span>(lmax &gt; rmax)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lmax &gt; Max)query_max(p[rt].l);</span><br><span class="line">        <span class="keyword">if</span>(rmax &gt; Max)query_max(p[rt].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rmax &gt; Max)query_max(p[rt].r);</span><br><span class="line">        <span class="keyword">if</span>(lmax &gt; Max)query_max(p[rt].l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            p[i].xy[<span class="number">0</span>] = scan(),p[i].xy[<span class="number">1</span>] = scan();</span><br><span class="line">        root = build(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            X = p[i].xy[<span class="number">0</span>],Y = p[i].xy[<span class="number">1</span>];</span><br><span class="line">            Min = inf,Max = -inf;</span><br><span class="line">            query_min(root),query_max(root);</span><br><span class="line">            ans = min(ans, Max - Min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ2468 SJY摆棋子(kd_Tree模板题)</title>
    <url>/bcRevincent.github.io/BZOJ2468/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cDovL3d3dy5seWRzeS5jb20vSnVkZ2VPbmxpbmUvcHJvYmxlbS5waHA/aWQ9MjY0OA==">题目传送门：bzoj 2468</span></p>
<h1 id="1-题目"><a class="markdownIt-Anchor" href="#1-题目">#</a> 1. 题目</h1>
<p>黑棋子插入到 kd_Tree 中，白棋子跳过。</p>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2. 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Problem: 2648</span></span><br><span class="line"><span class="comment">    User: Revincent</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:13984 ms</span></span><br><span class="line"><span class="comment">    Memory:63324 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> root,d;</span><br><span class="line"><span class="keyword">int</span> Min,Max;</span><br><span class="line"><span class="keyword">int</span> n,m,op,x,y;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,xy[<span class="number">2</span>],Max[<span class="number">2</span>],Min[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.xy[d] == b.xy[d])</span><br><span class="line">            <span class="keyword">return</span> a.xy[d^<span class="number">1</span>] &lt; b.xy[d^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a.xy[d] &lt; b.xy[d];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; kd_tree[N&lt;&lt;<span class="number">2</span>],_new;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt, node a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kd_tree[rt].Min[<span class="number">0</span>] = min(kd_tree[rt].Min[<span class="number">0</span>], a.Min[<span class="number">0</span>]);</span><br><span class="line">    kd_tree[rt].Max[<span class="number">0</span>] = max(kd_tree[rt].Max[<span class="number">0</span>], a.Max[<span class="number">0</span>]);</span><br><span class="line">    kd_tree[rt].Min[<span class="number">1</span>] = min(kd_tree[rt].Min[<span class="number">1</span>], a.Min[<span class="number">1</span>]);</span><br><span class="line">    kd_tree[rt].Max[<span class="number">1</span>] = max(kd_tree[rt].Max[<span class="number">1</span>], a.Max[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> o)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    d = o;</span><br><span class="line">    nth_element(kd_tree+l, kd_tree+mid, kd_tree+r+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">        kd_tree[mid].Min[i] = kd_tree[mid].Max[i] = kd_tree[mid].xy[i];</span><br><span class="line">    kd_tree[mid].l = kd_tree[mid].r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; mid)kd_tree[mid].l = build(l, mid<span class="number">-1</span>, o^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)kd_tree[mid].r = build(mid+<span class="number">1</span>, r, o^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(kd_tree[mid].l)push_up(mid, kd_tree[kd_tree[mid].l]);</span><br><span class="line">    <span class="keyword">if</span>(kd_tree[mid].r)push_up(mid, kd_tree[kd_tree[mid].r]);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _insert(<span class="keyword">int</span> rt, <span class="keyword">int</span> o)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_new.xy[o] &gt;= kd_tree[rt].xy[o])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(kd_tree[rt].r)</span><br><span class="line">            _insert(kd_tree[rt].r, o^<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            kd_tree[rt].r = ++n;</span><br><span class="line">            kd_tree[n] = _new;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(kd_tree[rt].l)</span><br><span class="line">            _insert(kd_tree[rt].l, o^<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            kd_tree[rt].l = ++n;</span><br><span class="line">            kd_tree[n] = _new;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(kd_tree[rt].l)push_up(rt, kd_tree[kd_tree[rt].l]);</span><br><span class="line">    <span class="keyword">if</span>(kd_tree[rt].r)push_up(rt, kd_tree[kd_tree[rt].r]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(node a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; a.Max[<span class="number">0</span>])res += x - a.Max[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(x &lt; a.Min[<span class="number">0</span>])res += a.Min[<span class="number">0</span>] - x;</span><br><span class="line">    <span class="keyword">if</span>(y &gt; a.Max[<span class="number">1</span>])res += y - a.Max[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(y &lt; a.Min[<span class="number">1</span>])res += a.Min[<span class="number">1</span>] - y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis = <span class="built_in">abs</span>(kd_tree[rt].xy[<span class="number">0</span>] - x) + <span class="built_in">abs</span>(kd_tree[rt].xy[<span class="number">1</span>] - y);</span><br><span class="line">    ans = min(ans, dis);</span><br><span class="line">    <span class="keyword">int</span> lmin = inf,rmin = inf;</span><br><span class="line">    <span class="keyword">int</span> l = kd_tree[rt].l,r = kd_tree[rt].r;</span><br><span class="line">    <span class="keyword">if</span>(l)lmin = get_min(kd_tree[l]);</span><br><span class="line">    <span class="keyword">if</span>(r)rmin = get_min(kd_tree[r]);</span><br><span class="line">    <span class="keyword">if</span>(lmin &lt; rmin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lmin &lt; ans)query(l);</span><br><span class="line">        <span class="keyword">if</span>(rmin &lt; ans)query(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rmin &lt; ans)query(r);</span><br><span class="line">        <span class="keyword">if</span>(lmin &lt; ans)query(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;kd_tree[i].xy[<span class="number">0</span>],&amp;kd_tree[i].xy[<span class="number">1</span>]);</span><br><span class="line">    root = build(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _new.l = <span class="number">0</span>,_new.r = <span class="number">0</span>;</span><br><span class="line">            _new.xy[<span class="number">0</span>] = _new.Min[<span class="number">0</span>] = _new.Max[<span class="number">0</span>] = x;</span><br><span class="line">            _new.xy[<span class="number">1</span>] = _new.Min[<span class="number">1</span>] = _new.Max[<span class="number">1</span>] = y;</span><br><span class="line">            _insert(root, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = inf;</span><br><span class="line">            query(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3966（树链剖分 + 区间更新 + 点查询）</title>
    <url>/bcRevincent.github.io/HDU3966/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0vSERVLTM5NjY=">题目传送门</span></p>
<h1 id="1-题目大意及思路"><a class="markdownIt-Anchor" href="#1-题目大意及思路">#</a> 1 题目大意及思路</h1>
<p>一颗 N 个结点的树，给你 P 次操作</p>
<p>操作 I ：结点 C1–&gt;C2 之间的所有结点权值加 K；</p>
<p>操作 D：结点 C1-&gt;C2 之间的所有结点权值减 K；</p>
<p>操作 Q：询问结点 C 的值。</p>
<p>思路：这一眼看上去就知道是一道裸的树链剖分 (点操作)，就不多说了直接上代码。没学过树链剖分的建议先入门再来看代码。</p>
<hr>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,next;</span><br><span class="line">&#125; edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pre[N],cnt;</span><br><span class="line"><span class="keyword">int</span> son[N],dep[N],siz[N];</span><br><span class="line"><span class="keyword">int</span> tid[N],id,top[N],fa[N];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">int</span> num[N],add[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, ch, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((ch = getchar()) == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        res = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="keyword">sizeof</span>(siz));</span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span>(add));</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].v = v;</span><br><span class="line">    edge[cnt].next = pre[u];</span><br><span class="line">    pre[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = dp;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    son[u] = <span class="number">0</span>;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(v, u, dp+<span class="number">1</span>);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[v] &gt; siz[son[u]])</span><br><span class="line">                son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tid[u] = ++id;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    <span class="keyword">if</span>(son[u])</span><br><span class="line">        dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != fa[u] &amp;&amp; v != son[u])</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">    &#123;</span><br><span class="line">        add[rt] += v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(add[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>] += add[rt];</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[rt];</span><br><span class="line">        add[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)</span><br><span class="line">        update(rt&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, v);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)</span><br><span class="line">        update(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == pos)</span><br><span class="line">        <span class="keyword">return</span> add[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(add[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>] += add[rt];</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[rt];</span><br><span class="line">        add[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> query(rt&lt;&lt;<span class="number">1</span>, l, mid, pos);</span><br><span class="line">    <span class="keyword">return</span> query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            swap(u, v);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, n, tid[top[u]], tid[u], k);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v])</span><br><span class="line">        swap(u, v);</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">1</span>, n, tid[u], tid[v], k);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n,&amp;m,&amp;p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            num[i] = scan();</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = scan();</span><br><span class="line">            <span class="keyword">int</span> v = scan();</span><br><span class="line">            addEdge(u, v);</span><br><span class="line">            addEdge(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(p--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> c1,c2,k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;c1,&amp;c2,&amp;k);</span><br><span class="line">                LCA(c1, c2, k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;c1,&amp;c2,&amp;k);</span><br><span class="line">                LCA(c1, c2, -k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c1);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num[c1] + query(<span class="number">1</span>, <span class="number">1</span>, n, tid[c1]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3237 Tree(树链剖分 + 单点更新 + 区间更新 + 区间查询)</title>
    <url>/bcRevincent.github.io/POJ3237/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L2NvbnRlc3QvMTU3MjM0I3Byb2JsZW0vSA==">题目传送门：POJ 3237 Tree</span></p>
<h1 id="1-题目大意及思路"><a class="markdownIt-Anchor" href="#1-题目大意及思路">#</a> 1. 题目大意及思路</h1>
<p>这道题就是在 SPOJ-QTREE 这道题目上加了区间更新关键就是权值取反部分怎么处理，取反后最大值将会是原来的最小值，所以既要存最大值，又要存最小值。取反后最大值为原来的最小值取反，最小值为原来的最大值取反。在这里我是用 add 这个数组当作懒标记数组，当一个区间取两次反时还是原来的最大值和最小值，因此要取 add [rt] 数组进行 %2 操作，当 add [rt] 为 1 的时候向下传递标记，否则不传递。</p>
<hr>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2. 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,next;</span><br><span class="line">&#125; edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> e[N][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> son[N],dep[N],fa[N];</span><br><span class="line"><span class="keyword">int</span> id,tid[N],top[N],siz[N];</span><br><span class="line"><span class="keyword">int</span> cnt,pre[N];</span><br><span class="line"><span class="keyword">int</span> Max[N&lt;&lt;<span class="number">2</span>],Min[N&lt;&lt;<span class="number">2</span>],add[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> T,n,a,b,c;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> res = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27; &#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        res = res * <span class="number">10</span> +  ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> flag * res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="keyword">sizeof</span>(siz));</span><br><span class="line">    <span class="built_in">memset</span>(Max, -inf, <span class="keyword">sizeof</span>(Max));</span><br><span class="line">    <span class="built_in">memset</span>(Min, inf, <span class="keyword">sizeof</span>(Min));</span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span>(add));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v;</span><br><span class="line">    edge[cnt].next = pre[u];</span><br><span class="line">    pre[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u] = f,dep[u] = dp,son[u] = <span class="number">0</span>,siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(v, u, dp+<span class="number">1</span>);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[v] &gt; siz[son[u]])</span><br><span class="line">                son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u] = tp,tid[u] = ++id;</span><br><span class="line">    <span class="keyword">if</span>(son[u])</span><br><span class="line">        dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != fa[u] &amp;&amp; v != son[u])</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Max[rt] = max(Max[rt&lt;&lt;<span class="number">1</span>], Max[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    Min[rt] = min(Min[rt&lt;&lt;<span class="number">1</span>], Min[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(add[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>] = (add[rt&lt;&lt;<span class="number">1</span>] + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = (add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">        add[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxl = Max[rt&lt;&lt;<span class="number">1</span>],maxr = Max[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        Max[rt&lt;&lt;<span class="number">1</span>] = -Min[rt&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        Min[rt&lt;&lt;<span class="number">1</span>] = -maxl;</span><br><span class="line">        Max[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = -Min[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        Min[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = -maxr;</span><br><span class="line">        push_up(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == pos)</span><br><span class="line">    &#123;</span><br><span class="line">        add[rt] = <span class="number">0</span>;</span><br><span class="line">        Max[rt] = Min[rt] = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">        update_1(rt&lt;&lt;<span class="number">1</span>, l, mid, pos, v);</span><br><span class="line">    <span class="keyword">else</span> update_1(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, pos, v);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[e[i][<span class="number">0</span>]] &gt; dep[e[i][<span class="number">1</span>]])</span><br><span class="line">            swap(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]);</span><br><span class="line">        update_1(<span class="number">1</span>, <span class="number">2</span>, n, tid[e[i][<span class="number">1</span>]], e[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">    &#123;</span><br><span class="line">        add[rt] = (add[rt] + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mmax = Max[rt];</span><br><span class="line">        Max[rt] = -Min[rt],Min[rt] = -mmax;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)</span><br><span class="line">        update_2(rt&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)</span><br><span class="line">        update_2(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    push_up(rt);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_up</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            swap(u, v);</span><br><span class="line">        update_2(<span class="number">1</span>, <span class="number">2</span>, n, tid[top[u]], tid[u]);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u != v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[u] &gt; dep[v])</span><br><span class="line">            swap(u, v);</span><br><span class="line">        update_2(<span class="number">1</span>, <span class="number">2</span>, n, tid[u]+<span class="number">1</span>, tid[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> Max[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    push_down(rt);</span><br><span class="line">    <span class="keyword">if</span>(qr &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> query(rt&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(ql &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> max(query(rt&lt;&lt;<span class="number">1</span>, l, mid, ql, qr), query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca_query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            swap(u, v);</span><br><span class="line">        ans = max(ans, query(<span class="number">1</span>, <span class="number">2</span>, n, tid[top[u]], tid[u]));</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u != v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[u] &gt; dep[v])</span><br><span class="line">            swap(u, v);</span><br><span class="line">        ans = max(ans, query(<span class="number">1</span>, <span class="number">2</span>, n, tid[u]+<span class="number">1</span>, tid[v]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = Scan();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        n = Scan();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            e[i][<span class="number">0</span>] = Scan(),e[i][<span class="number">1</span>] = Scan(),e[i][<span class="number">2</span>] = Scan();</span><br><span class="line">            addEdge(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]);</span><br><span class="line">            addEdge(e[i][<span class="number">1</span>], e[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        deal();</span><br><span class="line">        <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op) &amp;&amp; op[<span class="number">0</span>] != <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = Scan(),b = Scan();</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                update_1(<span class="number">1</span>, <span class="number">2</span>, n, tid[e[a][<span class="number">1</span>]], b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">                lca_up(a, b);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lca_query(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ-QTREE</title>
    <url>/bcRevincent.github.io/SPOJ-QTREE/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L2NvbnRlc3QvMTU3MjM0I3Byb2JsZW0vQQ==">题目传送门</span></p>
<h1 id="1-题目大意"><a class="markdownIt-Anchor" href="#1-题目大意">#</a> 1. 题目大意</h1>
<p>一棵树，N 个结点，任意次操作。</p>
<p>操作 Change ：a，b  将第 a 条边的权值改为 b；</p>
<p>操作 Query：a，b  查询结点 a-&gt;b 路径上的最大边权。</p>
<p>这是一道很裸的关于边操作的树链剖分题目，不多说了，直接上代码。</p>
<hr>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2. 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> T,n,a,b,c;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> pre[N],cnt;</span><br><span class="line"><span class="keyword">int</span> son[N],dep[N],tid[N];</span><br><span class="line"><span class="keyword">int</span> top[N],fa[N],siz[N],id;</span><br><span class="line"><span class="keyword">int</span> maxx[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> e[N][<span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(maxx, -inf, <span class="keyword">sizeof</span>(maxx));</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="keyword">sizeof</span>(siz));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].v = v;</span><br><span class="line">    edge[cnt].next = pre[u];</span><br><span class="line">    pre[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = dp;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    son[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(v, u, dp+<span class="number">1</span>);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[v] &gt; siz[son[u]])</span><br><span class="line">                son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    tid[u] = ++id;</span><br><span class="line">    <span class="keyword">if</span>(son[u] == <span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != son[u] &amp;&amp; v != fa[u])</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r &amp;&amp; l == pos)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx[rt] = w;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">        update(rt&lt;&lt;<span class="number">1</span>, l, mid, pos, w);</span><br><span class="line">    <span class="keyword">else</span> update(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, pos, w);</span><br><span class="line">    maxx[rt] = max(maxx[rt&lt;&lt;<span class="number">1</span>], maxx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">        <span class="keyword">return</span> maxx[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> query(rt&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(ql &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> max(query(rt&lt;&lt;<span class="number">1</span>, l, mid, ql, qr), query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        <span class="comment">//if(top[x]==x)</span></span><br><span class="line">            ans = max(ans, query(<span class="number">1</span>, <span class="number">2</span>, n, tid[top[x]], tid[x]));</span><br><span class="line">        <span class="comment">//else ans = max(ans, query(1, 2, n, tid[top[x]]+1, tid[x]));</span></span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x != y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        ans = max(ans, query(<span class="number">1</span>, <span class="number">2</span>, n, tid[x]+<span class="number">1</span>, tid[y]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[e[i][<span class="number">0</span>]] &gt; dep[e[i][<span class="number">1</span>]])</span><br><span class="line">            swap(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>]);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">2</span>, n, tid[e[i][<span class="number">1</span>]], e[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line">            addEdge(a, b, c);</span><br><span class="line">            addEdge(b, a, c);</span><br><span class="line">            e[i][<span class="number">0</span>] = a,e[i][<span class="number">1</span>] = b,e[i][<span class="number">2</span>] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        deal();</span><br><span class="line">        <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op) &amp;&amp; op[<span class="number">0</span>]!=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, get(a, b));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                update(<span class="number">1</span>, <span class="number">2</span>, n, tid[e[a][<span class="number">1</span>]], b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/bcRevincent.github.io/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo</span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting</span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub</span>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start">#</a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post">#</a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing</span></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server">#</a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server</span></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files">#</a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating</span></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites">#</a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment</span></p>
]]></content>
  </entry>
  <entry>
    <title>POJ3694 Network(Tarjan求割边+LCA)</title>
    <url>/bcRevincent.github.io/POJ3694/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L2NvbnRlc3QvMTU0NDk0I3Byb2JsZW0vRA==">题目传送门：POJ 3694</span></p>
<h1 id="1-题目大意及思路"><a class="markdownIt-Anchor" href="#1-题目大意及思路">#</a> 1. 题目大意及思路</h1>
<p>给你一个图，有 Q 个操作，每个操作将点 u 和 v 之间连一条边，问你在每次加边之后图中的割边的数量。</p>
<p>分析：首先用 Tarjan 在加边前求一次割边的数量，并用并查集缩点，缩点之后的图将会变成一棵树。加边时，任意两点之间直接暴力求 LCA，在求 LCA 的过程更新割边的数量。因为一棵树加上一条边之后必定有环，那么就割边的数量就会减少。具体实现看代码。</p>
<hr>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2. 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pre[N],cnt;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],id;</span><br><span class="line"><span class="keyword">int</span> fa[N],f[N];</span><br><span class="line"><span class="keyword">int</span> n,m,q,cut;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar())==<span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = id = cut = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v;</span><br><span class="line">    edge[cnt].next = pre[u];</span><br><span class="line">    pre[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = x;</span><br><span class="line">    <span class="keyword">while</span>(x != f[x])</span><br><span class="line">        x = f[x];</span><br><span class="line">    <span class="keyword">while</span>(xx != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = f[xx];</span><br><span class="line">        f[xx] = x;</span><br><span class="line">        xx = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _union(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    f[_find(y)] = _find(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++id;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pre[u]; ~i; i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u])</span><br><span class="line">                cut++;</span><br><span class="line">            <span class="keyword">else</span> _union(u, v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v != fa[u])</span><br><span class="line">            low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] &gt; dfn[v])</span><br><span class="line">        swap(u, v);</span><br><span class="line">    <span class="keyword">int</span> x = _find(u);</span><br><span class="line">    <span class="keyword">while</span>(dfn[v] &gt; dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = _find(v);</span><br><span class="line">        <span class="keyword">if</span>(x != y)cut--;</span><br><span class="line">        f[y] = x;</span><br><span class="line">        v = fa[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y = _find(v);</span><br><span class="line">    <span class="keyword">while</span>(u != v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = _find(u);</span><br><span class="line">        <span class="keyword">if</span>(y != x)cut--;</span><br><span class="line">        f[x] = y;</span><br><span class="line">        u = fa[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cut);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m), n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            u = Scan(),v = Scan();</span><br><span class="line">            addEdge(u, v);</span><br><span class="line">            addEdge(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        Tarjan(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, ++cas);</span><br><span class="line">        q = Scan();</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            u = Scan(),v = Scan();</span><br><span class="line">            LCA(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>图片与代码块共存样例</title>
    <url>/bcRevincent.github.io/python/</url>
    <content><![CDATA[<h1 id="1-插入图片"><a class="markdownIt-Anchor" href="#1-插入图片">#</a> 1. 插入图片</h1>
<h2 id="-swig1-图片"><a class="markdownIt-Anchor" href="#-swig1-图片">#</a> <img data-src="/bcRevincent.github.io/python/python.jpg" class="" title="图片1"><br>
<img data-src="python.jpg" alt="图片"></h2>
<h1 id="2-插入代码块"><a class="markdownIt-Anchor" href="#2-插入代码块">#</a> 2. 插入代码块</h1>
<h2 id="-code0-"><a class="markdownIt-Anchor" href="#-code0-">#</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image </span><br></pre></td></tr></table></figure></h2>
<h1 id="3-插入公式"><a class="markdownIt-Anchor" href="#3-插入公式">#</a> 3. 插入公式</h1>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mn>3</mn><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msqrt><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sqrt {3x-1}+(1+x)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.17444499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">3</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<hr>
<p>这是第 2 次更新！！！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Fun with the Fellowship(矩阵快速幂)</title>
    <url>/bcRevincent.github.io/untitled-c1/</url>
    <content><![CDATA[<h1 id="1-题目描述及分析"><a class="markdownIt-Anchor" href="#1-题目描述及分析">#</a> 1. 题目描述及分析</h1>
<p><strong>Problem Description</strong></p>
<p>Legolas, Gimli and Aragorn have just fought an army of orcs and now want to relax for the day. Their way of having fun is to play an archery contest with Legolas trying to hit any object that the other two point to. However, Aragorn soon realises that Legolas is too good for this game. He adds a twist to the game. Aragorn will now point to 4 targets and assign some number of points (a,b,c,d) to those 4 targets - the points will be unique for each target. Gimli will then give Legolas a number n and Legolas has to tell how many ways he can hit any of those 4 targets one after the other in any order so that the total points scored will be n. Now Legolas is a genius in archery but he’s stumped by this question. Help Legolas!</p>
<p>You have to print the answer modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000000007</mn><mo stretchy="false">(</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1000000007 (10^9+7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>.</p>
<p><strong>Input Format</strong></p>
<p>There is only one line in input with 5 space-separated integers - a b c d n</p>
<p>The last 3 test cases are for Extra Credit.</p>
<p><strong>Constraints</strong></p>
<p 18=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo>&lt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1 &lt;= a,b,c,d &lt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a,b,c,d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span> are unique <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 &lt;= n &lt;= 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> For extra credit: 1 <= n <= 10^</p>
<p><strong>Output Format</strong></p>
<p>Print the number of ways Legolas can get to the target number modulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000000007</mn><mo stretchy="false">(</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1000000007 (10^9+7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span><span class="mopen">(</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>. If it is impossible, print 0.</p>
<p><strong>Sample Input 1</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2 3 5 7 8</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output 1</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<p><strong>Explanation 1</strong></p>
<p>The 6 ways of scoring a total of 8 are (2 + 2 + 2 + 2), (2 + 3 + 3), (3 + 2 + 3), (3 + 3 + 2), (3 + 5), and (5 + 3).</p>
<p><strong>分析：</strong></p>
<p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n &lt;= 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 时，可以用一维<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 解决，类似于多重背包，状态转移方程为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i-a] + dp[i-b] + dp[i-c] + dp[i-d]</span><br></pre></td></tr></table></figure>
<p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 级别的时候，很明显可以根据一维<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 的状态转移方程构造出系数矩阵，利用矩阵快速幂解决。</p>
<p>考虑到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo>&lt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1&lt;=a,b,c,d&lt;=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，所以系数矩阵应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>x</mi><mn>10</mn></mrow><annotation encoding="application/x-tex">10x10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的，构造方法同一般的矩阵快速幂一样。</p>
<p>这个就是根据样例构造的系数矩阵，只需要在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">a,b,c,d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span></span></span></span> 对应的位置置为 1，其余全为 0 即可。</p>
<img data-src="/bcRevincent.github.io/untitled-c1/matrix.png" class="" title="构造的矩阵样例">
<hr>
<p>用公式可以表达为：</p>
<img data-src="/bcRevincent.github.io/untitled-c1/formula.png" class="" title="构造的快速幂公式">
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 就是上面构造的那个系数矩阵，接下来要做的就是求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mn>1..10</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[1..10]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>10</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">A^{(n-10)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>下面给出代码.</p>
<hr>
<h1 id="2-解题代码"><a class="markdownIt-Anchor" href="#2-解题代码">#</a> 2. 解题代码</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll mat[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">&#125;base,ans;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">11</span>],w[<span class="number">4</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(w, w+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    a = w[<span class="number">0</span>],b = w[<span class="number">1</span>],c = w[<span class="number">2</span>],d = w[<span class="number">3</span>];</span><br><span class="line">    f[a] = f[b] = f[c] = f[d] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(i &gt; w[j])</span><br><span class="line">                f[i] += f[i-w[j]];</span><br><span class="line">    <span class="built_in">memset</span>(base.mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(base.mat));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        base.mat[<span class="number">0</span>][w[i]<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        base.mat[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ans.mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans.mat));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        ans.mat[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">matrix <span class="title">matrixMultiply</span><span class="params">(matrix a, matrix b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            c.mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">                c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickPow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m = n - <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m &amp; <span class="number">1</span>)</span><br><span class="line">            ans = matrixMultiply(ans, base);</span><br><span class="line">        base = matrixMultiply(base, base);</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%lld&quot;</span>, &amp;w[<span class="number">0</span>],&amp;w[<span class="number">1</span>],&amp;w[<span class="number">2</span>],&amp;w[<span class="number">3</span>],&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            quickPow();</span><br><span class="line">            ll ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">                ret = (ret + ans.mat[<span class="number">0</span>][i] * f[<span class="number">10</span>-i]) % mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">init()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 函数中，初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mn>1..10</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[1..10]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的过程就是求解小范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的过程。只需要把 10 改成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 即可。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>windows环境下pytorch使用num_worker</title>
    <url>/bcRevincent.github.io/pytorch-num-worker/</url>
    <content><![CDATA[<h2 id="在pytorch中我们可以通过设置num_worker的数量来提高数据加载的速度从而减少将数据从cpu加载到gpu的时间开销以提高gpu的利用率进而加快模型的训练速度"><a class="markdownIt-Anchor" href="#在pytorch中我们可以通过设置num_worker的数量来提高数据加载的速度从而减少将数据从cpu加载到gpu的时间开销以提高gpu的利用率进而加快模型的训练速度">#</a> 在 pytorch 中，我们可以通过设置 num_worker 的数量来提高数据加载的速度，从而减少将数据<br>
从 CPU 加载到 GPU 的时间开销，以提高 GPU 的利用率，进而加快模型的训练速度。</h2>
<h2 id="在linux环境下设置dataloader的num_worker数量大于0是可以正常运行的但是在windows环境下会报错只能设置num_worker0才可以正常运行但是这样会使得模型的训练速度极其漫长"><a class="markdownIt-Anchor" href="#在linux环境下设置dataloader的num_worker数量大于0是可以正常运行的但是在windows环境下会报错只能设置num_worker0才可以正常运行但是这样会使得模型的训练速度极其漫长">#</a> 在 linux 环境下设置 dataLoader 的 num_worker 数量大于 0 是可以正常运行的，但是在<br>
 Windows 环境下会报错，只能设置 num_worker=0 才可以正常运行，但是这样会使得模型<br>
的训练速度极其漫长…</h2>
<h2 id="如果还是想在windows环境下在pytorch中启用多线程加载数据那么应该怎么办呢这个问题我找了很久很久很久才找到解决方案"><a class="markdownIt-Anchor" href="#如果还是想在windows环境下在pytorch中启用多线程加载数据那么应该怎么办呢这个问题我找了很久很久很久才找到解决方案">#</a> 如果还是想在 Windows 环境下在 pytorch 中启用多线程加载数据，那么应该怎么办呢？<br>
这个问题我找了很久很久很久… 才找到解决方案！！！</h2>
<p><big><em><strong>torchnet + dataloader</strong></em></big></p>
<hr>
<ol>
<li>安装 torchnet</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install torchnet</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>自定义 dataLoader</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DataLoader:</span><br><span class="line">    def __init__(self, ...):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    def get_task_batch(self, ...):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    def get_iterator(self):</span><br><span class="line">        tnt_dataset &#x3D; torchnet.dataset.ListDataset(</span><br><span class="line">            elem_list&#x3D;range(self.task_num), load&#x3D;self.get_task_batch)</span><br><span class="line">        data_loader &#x3D; tnt_dataset.parallel(</span><br><span class="line">            batch_size&#x3D;self.batch_size,</span><br><span class="line">            num_workers&#x3D;self.num_workers,</span><br><span class="line">            drop_last&#x3D;True,</span><br><span class="line">            # 此函数可以使每个worker使用不同的随机种子</span><br><span class="line">            worker_init_fn&#x3D;self.worker_init_fn_seed,</span><br><span class="line">            shuffle&#x3D;(False if self.test else True))</span><br><span class="line">        return data_loader</span><br><span class="line">    </span><br><span class="line">    def worker_init_fn_seed(self, worker_id):</span><br><span class="line">        seed &#x3D; 10 + 5 * worker_id</span><br><span class="line">        np.random.seed(seed)</span><br><span class="line">    </span><br><span class="line">    def __call__(self):</span><br><span class="line">        return self.get_iterator()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在主程序中使用方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MiniImagenet为预处理数据的类</span><br><span class="line">dataset &#x3D; MiniImagenet(data_path, ...)</span><br><span class="line">loader &#x3D; DataLoader(dataset, num_workers&#x3D;2, ...)</span><br><span class="line">for step, batch in enumerate(loader()):</span><br><span class="line">    x, y &#x3D; batch</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
</search>
